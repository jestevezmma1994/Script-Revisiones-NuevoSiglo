#!/bin/sh
. /etc/strings.txt
ubi_create_ctrl() {
if [ ! -e /dev/shm/ubi_ctrl ]; then
UBICTRL_MAJOR=`cat /sys/class/misc/ubi_ctrl/dev | cut -d: -f1`
UBICTRL_MINOR=`cat /sys/class/misc/ubi_ctrl/dev | cut -d: -f2`
rm -f /dev/shm/ubi_ctrl
mknod /dev/shm/ubi_ctrl c $UBICTRL_MAJOR $UBICTRL_MINOR
fi
}
ubi_attach() {
ubidetach /dev/shm/ubi_ctrl -p /dev/$2 >/dev/null 2>&1
flash_eraseall /dev/$2 >/dev/null 2>&1
ubiformat -y -q /dev/$2 >/dev/null 2>&1 || exit_upgrade 103 "Cannot format UBI device "$2
ubiattach /dev/shm/ubi_ctrl -p /dev/$2 -d $1 >/dev/null 2>&1 || exit_upgrade 103 "Cannot attach UBI device "$1
rm -f /dev/shm/ubi$1
mknod /dev/shm/ubi$1 c `cat /sys/class/ubi/ubi$1/dev | cut -d: -f1` `cat /sys/class/ubi/ubi$1/dev | cut -d: -f2` || exit_upgrade 103 "Unable to create UBI volume node #"$1
}
_UP_PLATFORM_NAME="bcm97xxx"
_UP_PLATFORM_STEP_CNT=0
#Mandatory procedures operating on data, you should escape to "exit_upgrade" with error code if something goes criticaly wrong
_up_get_hash () { 
setnv | grep "^SV_VERSION=" | cut -d'=' -f2
}
_up_get_status () { 
setnv | grep "^SV_STATUS=" | cut -d'=' -f2
}
_up_set_status () {
setnv SV_STATUS "$1"
}
_up_check_version() { 
res="not needed in unsecure version"
}
_up_verify_firmware () { 
res="not needed in unsecure version"
}
_up_before_main_fifo_create() { 
#"ROOTFS.sqsh KERNEL.gz LOGO.bin USR.sqsh"
if [ -f image.sizes ]; then
_UP_PLATFORM_TAR_FILES=`cat image.sizes | sed -e "s/\.size.*//g"`
else
_UP_PLATFORM_TAR_FILES="ROOTFS.ubi KERNEL.gz LOGO.bin"
fi
#"rootfs kernel logo usr"
_UP_PLATFORM_TAR_PIPES=$(for i in  $_UP_PLATFORM_TAR_FILES; do echo $i.pipe; done)
}
_up_write_firmware () { 
HASH=$1
shift
SLOT=
for CMD in `cat /proc/cmdline`; do
if [ "$(echo $CMD | cut -d'=' -f 1)" = "slot" ]; then
SLOT=$(echo $CMD | cut -d'=' -f 2)
echo "I:0980: Found slot number $SLOT in kernel commandline"
break
fi
done
if [ -z "$SLOT" ]; then
echo "I:0980: Warning - falling back to slot selection based on NVRAM"
SLOT=`setnv | grep "^SV_SLOT=" | tail -n 1 | cut -d'=' -f2-`
if [ -z "$SLOT" ]; then
exit_upgrade 103 "Unable to get current slot number"
fi
fi
SLOT=$(( ! $SLOT ))
echo "I:0981: selected slot #$SLOT"
SPART=`cat /proc/mtd | grep "\<slot$(( $SLOT ))\>" | cut -d':' -f1`
KPART=`cat /proc/mtd | grep "\<vmlinuz$(( $SLOT ))\>" | cut -d':' -f1`
RPART=`cat /proc/mtd | grep "\<rootfs$(( $SLOT ))\>" | cut -d':' -f1`
LPART=`cat /proc/mtd | grep "\<logo$(( $SLOT ))\>" | cut -d':' -f1`
[ -z "$LPART" ] && LPART=`cat /proc/mtd | grep "\<logo\>" | cut -d':' -f1`
UPART=`grep ".d.$" /proc/partitions | head -n1 | sed "s/.*\(.d.\)$/\1/g"`$(( 5 + SLOT ));
if [ -z "$(echo 'ROOTFS.ubi KERNEL.gz LOGO.bin' | grep -s '\bROOTFS.vmx\b\|\bROOTFS.latens\b\|\bBOOTIMAGE.vmx\b\|\bBOOTIMAGE.qb\b\|\bBOOTIMAGE.latens\b')" ]; then
[ -z "$KPART" -o -z "$RPART" ] && exit_upgrade 103 "flash partition not found";
elif echo 'ROOTFS.ubi KERNEL.gz LOGO.bin' | grep -s '\bBOOTIMAGE.vmx\b\|\bBOOTIMAGE.qb\b\|\bBOOTIMAGE.latens\b'; then
[ -z "$SPART" ] && exit_upgrade 103 "flash partition not found";
else
[ -z "$KPART" ] && exit_upgrade 103 "flash partition not found";
fi
echo $SPART > SPART
echo $KPART > KPART
echo $RPART > RPART
echo $LPART > LPART
echo $UPART > UPART
_up_write_and_feedback () {
PIPE="$1.pipe"
FILE="$1"
WRITER="$2"
DEVICE="$3"
OPTIONAL="$4"
mkfifo $FILE.wc.pipe
{ 
if [ ! -z "$DEVICE" -a -e "$DEVICE" ]; then 
mkfifo $FILE
echo $WRITER | grep -q nandwrite
if [ $? -eq 0 ]; then
cat $FILE.wc.pipe | wc -c > $FILE.size && nandcat -l $(cat $FILE.size) $DEVICE > $FILE;
else
cat $FILE.wc.pipe | wc -c > $FILE.size && head -c $(cat $FILE.size) $DEVICE > $FILE;
fi
else
cat $FILE.wc.pipe > /dev/null;
fi
} & 
cat $PIPE | tar xO $FILE | tee $FILE.wc.pipe | \
$WRITER >$PIPE.log 2>&1; \
res=$?;
if [ "$OPTIONAL" = "optional" ] && [ ! -e $FILE.size -o "$(cat $FILE.size)" = "0" ]; then 
echo 0; [ ! -e "$DEVICE" ] ||  dd if=/dev/zero of=$DEVICE bs=32k count=1;
else
echo $res;
fi > $PIPE.?;
}
{
if echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bBOOTIMAGE.vmx\b"; then
if [ -f /sys/class/mtd/$SPART/type ]; then
if [ "$(cat /sys/class/mtd/$SPART/type)" = "nand" ]; then
flash_eraseall -q /dev/$SPART >/dev/null 2>&1
_up_write_and_feedback BOOTIMAGE.vmx "nandwrite -mp /dev/$SPART -" /dev/$SPART
else
_up_write_and_feedback BOOTIMAGE.vmx "flashcp -v - /dev/$SPART" /dev/$SPART
fi
else
_up_write_and_feedback BOOTIMAGE.vmx "flashcp -v - /dev/$SPART" /dev/$SPART
fi
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bBOOTIMAGE.qb\b"; then
if [ -f /sys/class/mtd/$SPART/type ]; then
if [ "$(cat /sys/class/mtd/$SPART/type)" = "nand" ]; then
flash_eraseall -q /dev/$SPART >/dev/null 2>&1
_up_write_and_feedback BOOTIMAGE.qb "nandwrite -mp /dev/$SPART -" /dev/$SPART
else
_up_write_and_feedback BOOTIMAGE.qb "flashcp -v - /dev/$SPART" /dev/$SPART
fi
else
_up_write_and_feedback BOOTIMAGE.qb "flashcp -v - /dev/$SPART" /dev/$SPART
fi
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.sqsh\b"; then
if [ -f /sys/class/mtd/$RPART/type ]; then
if [ "$(cat /sys/class/mtd/$RPART/type)" = "nand" ]; then
flash_eraseall -q /dev/$RPART >/dev/null 2>&1
_up_write_and_feedback ROOTFS.sqsh "nandwrite -mp /dev/$RPART -" /dev/$RPART
else
_up_write_and_feedback ROOTFS.sqsh "flashcp -v - /dev/$RPART" /dev/$RPART
fi
else
_up_write_and_feedback ROOTFS.sqsh "flashcp -v - /dev/$RPART" /dev/$RPART
fi
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.tgz\b"; then
umount /dev/$(echo $RPART | sed s/mtd/mtdblock/) 2>/dev/null
flash_eraseall -q /dev/$RPART >/dev/null 2>&1
mkdir -p ROOTFS.mountpoint
mount -t jffs2 /dev/$(echo $RPART | sed s/mtd/mtdblock/) ROOTFS.mountpoint
_up_write_and_feedback ROOTFS.tgz "tar zx -C ROOTFS.mountpoint"
umount ROOTFS.mountpoint
sync
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.ubi\b"; then
ubi_create_ctrl
UBI_NUM=`echo $RPART | sed "s/mtd\([[:digit:]]*\)/\1/"`
umount `mount | grep "ubi$(($UBI_NUM)):UBI_rootfs$(( $SLOT ))" | cut -d' ' -f3` >/dev/null 2>&1
ubi_attach $UBI_NUM $RPART
UBI_SIZE=`grep ROOTFS.ubi image.sizes | sed -e 's/ROOTFS.*=//'`
ubimkvol /dev/shm/ubi$UBI_NUM -t static -N UBI_rootfs$(( $SLOT )) -s $UBI_SIZE >/dev/null 2>&1
UBI_VOL="ubi"$UBI_NUM"_0"
rm -rf /dev/shm/$UBI_VOL
mknod /dev/shm/$UBI_VOL c `cat "/sys/class/ubi/$UBI_VOL/dev" | cut -d: -f1` `cat "/sys/class/ubi/$UBI_VOL/dev" | cut -d: -f2`
_up_write_and_feedback ROOTFS.ubi "ubiupdatevol /dev/shm/$UBI_VOL -s $UBI_SIZE -"
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.vmx\b"; then
if [ -f /sys/class/mtd/$KPART/type ]; then
if [ "$(cat /sys/class/mtd/$KPART/type)" = "nand" ]; then
flash_eraseall -q /dev/$KPART >/dev/null 2>&1
_up_write_and_feedback ROOTFS.vmx "nandwrite -mp /dev/$KPART -" /dev/$KPART
else
_up_write_and_feedback ROOTFS.vmx "flashcp -v - /dev/$KPART" /dev/$KPART
fi
else
_up_write_and_feedback ROOTFS.vmx "flashcp -v - /dev/$KPART" /dev/$KPART
fi
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.latens\b"; then
_up_write_and_feedback ROOTFS.latens "dd of=/tmp/latens.img" /tmp/latens.img &
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bBOOTIMAGE.latens\b"; then
_up_write_and_feedback BOOTIMAGE.latens "dd of=/tmp/latens.img" /tmp/latens.img &
fi
} &
if [ -z "$(echo 'ROOTFS.ubi KERNEL.gz LOGO.bin' | grep -s '\bROOTFS.vmx\b\|\bROOTFS.latens\b\|\bBOOTIMAGE.vmx\b')" ]; then
if [ -f /sys/class/mtd/$KPART/type ]; then
if [ "$(cat /sys/class/mtd/$KPART/type)" = "nand" ]; then
flash_eraseall -q /dev/$KPART >/dev/null 2>&1
_up_write_and_feedback KERNEL.gz "nandwrite -mp /dev/$KPART -" /dev/$KPART &
else
_up_write_and_feedback KERNEL.gz "flashcp -v - /dev/$KPART" /dev/$KPART &
fi
else
_up_write_and_feedback KERNEL.gz "flashcp -v - /dev/$KPART" /dev/$KPART &
fi
fi
_up_write_and_feedback USR.sqsh "dd of=" /dev/$UPART optional &
echo "I:0990: processing logo"
skip_logo () {
echo 0 > LOGO.bin.pipe.?; echo "I:0999: $1, skipped"; exit 0;
};
{
cat LOGO.bin.pipe | tar x LOGO.bin || skip_logo "logo not found in pack";
[ -z "$LPART" -o ! -e /dev/$LPART ] && skip_logo "logo partition not found";
[ ! -e LOGO.bin ] && skip_logo "logo partition not found";
if [ -f /sys/class/mtd/$LPART/type ]; then
if [ "$(cat /sys/class/mtd/$LPART/type)" = "nand" ]; then
nandcat -l `cat LOGO.bin | wc -c` /dev/$LPART | cmp -s LOGO.bin - && skip_logo "logo not changed"
flash_eraseall -q /dev/$LPART >/dev/null 2>&1
nandwrite -mp /dev/$LPART LOGO.bin >/dev/null 2>&1; echo $? > LOGO.bin.pipe.?;
else
head -c `cat LOGO.bin | wc -c` /dev/$LPART | cmp -s LOGO.bin - && skip_logo "logo not changed"
flashcp -v LOGO.bin /dev/$LPART >/dev/null 2>&1; echo $? > LOGO.bin.pipe.?;
fi
else
head -c `cat LOGO.bin | wc -c` /dev/$LPART | cmp -s LOGO.bin - && skip_logo "logo not changed"
flashcp -v LOGO.bin /dev/$LPART >/dev/null 2>&1; echo $? > LOGO.bin.pipe.?;
fi
} & echo $! >> back_pids
echo $SLOT > SLOT;
echo $HASH > HASH;
}
_up_verify_firmware () {
res="empty" 
}
_up_confirm_firmware () {
SLOT=`cat SLOT`
HASH=`cat HASH`
[ -z "$SLOT" ] && exit_upgrade 104 "slot number file not found"
[ -z "$HASH" ] && exit_upgrade 104 "hash file not found"
if [ -z "$(echo 'ROOTFS.ubi KERNEL.gz LOGO.bin' | grep -s '\bROOTFS.vmx\b\|\bROOTFS.latens\b\|\bBOOTIMAGE.vmx\b')" ]; then
setnv SV_SLOT "$SLOT" SV_STATUS "NEW" SV_VERSION "$HASH" \
$(cat $FW_NAME.sig | grep "KERNEL\|ROOTFS\|LOGO" | sed -e "s/KERNEL.*=/vmlinuz${SLOT}_sign /g" -e "s/ROOTFS.*=/rootfs${SLOT}_sign /" -e "s/LOGO.*=/splash_sign /") \
$(cat image.sizes | grep "KERNEL\|LOGO" | sed -e "s/KERNEL.*=/vmlinuz${SLOT}_size /g" -e "s/LOGO.*=/splash_size /g")
else
setnv SV_SLOT "$SLOT" SV_STATUS "NEW" SV_VERSION "$HASH" \
$(cat $FW_NAME.sig | grep "LOGO" | sed -e "s/LOGO.*=/splash_sign /") \
$(cat image.sizes | grep "LOGO" | sed -e "s/LOGO.*=/splash_size /g")
fi
}
_up_latens_verify_and_write () {
SLOT=`cat SLOT`
KPART=`cat KPART`
SPART=`cat SPART`
latens_sign_verifier /tmp/latens.img
if [ $? -ne 0 ]; then
return 1
else
if echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bROOTFS.latens\b"; then
PART=$KPART
elif echo "ROOTFS.ubi KERNEL.gz LOGO.bin" | grep -s "\bBOOTIMAGE.latens\b"; then
PART=$SPART
fi
if [ -z "$PART" ]; then
return 1
fi
if [[ -f /sys/class/mtd/$PART/type ]]; then
if [[ `cat /sys/class/mtd/$PART/type` == "nand" ]]; then
flash_erase -q /dev/$PART 0 0 > /dev/null 2>&1
nandwrite -mpq /dev/$PART /tmp/latens.img
else
flashcp -v /tmp/latens.img /dev/$PART
fi
else
flashcp -v /tmp/latens.img /dev/$PART
fi
if [ $? -ne 0 ]; then
return 1
fi
return 0
fi
}
#SOME_VARIABLE="SOME VALUE"
#Optional procedures calling before and after each phase of upgrade, shouldn't be implemented, but do not remove them from here
_up_before_wait_for_network () {
res="empty"
}
_up_after_wait_for_network () {
res="empty"
}
_up_before_wait_for_upgrade_server () {
res="empty"
}
_up_after_wait_for_upgrade_server () {
res="empty"
}
_up_before_version_check () {
res="empty"
}
_up_after_version_check () {
res="empty"
}
_up_before_initiate_upgrade () {
res="empty"
}
_up_after_initiate_upgrade () {
res="empty"
}
_up_before_getting_firmware () {
res="empty"
}
_up_after_getting_firmware () {
res="empty"
}
_up_before_firmware_verification () {
res="empty"
}
_up_after_firmware_verification () {
res="empty"
}
_up_before_writting_firmware () {
res="empty"
}
_up_after_writting_firmware () {
res="empty"
}
_up_before_complete () {
res="empty"
}
_up_after_complete () {
res="empty"
}
