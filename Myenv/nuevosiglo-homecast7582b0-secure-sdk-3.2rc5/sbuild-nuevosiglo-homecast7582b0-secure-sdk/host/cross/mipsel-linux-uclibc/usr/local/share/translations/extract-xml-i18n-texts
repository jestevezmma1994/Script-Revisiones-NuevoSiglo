#!/usr/bin/env python
from __future__ import print_function
import sys
import optparse
import xml.parsers.expat
import traceback
import time, datetime
import StringIO


header = """\
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\\n"
"Report-Msgid-Bugs-To: \\n"
"POT-Creation-Date: {0}\\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
"Language-Team: LANGUAGE <LL@li.org>\\n"
"Language: \\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=UTF-8\\n"
"Content-Transfer-Encoding: 8bit\\n"
"""


class TimeZone(datetime.tzinfo):
    def __init__(self):
        self._offset = time.timezone
        self._dst = time.altzone - self._offset if time.localtime().tm_isdst else 0

    def utcoffset(self, dt):
        return datetime.timedelta(seconds = -(self._offset + self._dst))

    def dst(self, dt):
        return datetime.timedelta(seconds = -self._dst)

    def format(self):
        offset = self._offset + self._dst
        hours = offset / 3600
        minutes = (offset - hours * 3600) / 60
        if hours < 0:
            return '+{0:0>2d}{1:0>2d}'.format(-hours, -minutes)
        else:
            return '-{0:0>2d}{1:0>2d}'.format(hours, minutes)


class Location(object):
    def __init__(self, filename, line_number):
        self._filename = filename
        self._line_number = line_number

    def __hash__(self):
        return hash((self._filename, self._line_number))

    def __eq__(self, other):
        if isinstance(other, Location):
            return self._filename == other._filename and self._line_number == other._line_number
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    @property
    def filename(self):
        return self._filename

    @property
    def line_number(self):
        return self._line_number


class Message(object):
    def __init__(self, id):
        self._id = id
        self._locations = set()

    @property
    def id(self):
        return self._id

    def add_location(self, filename, line_number):
        self._locations.add(Location(filename, line_number))

    def dump(self, stream, no_location = False):
        if not no_location:
            for loc in sorted(list(self._locations), key = lambda loc: '{0.filename}:{0.line_number:0>9d}'.format(loc)):
                stream.write('#: {0}:{1}\n'.format(loc.filename, loc.line_number))
        msg_id = self._id.replace('\\', '\\\\').replace('"', '\\"')
        if msg_id.find('\n') < 0:
            formatted_id = '"' + msg_id + '"'
        else:
            formatted_id = '""\n"' + '\\n"\n"'.join(msg_id.split('\n')) + '"'
        stream.write('msgid ' + formatted_id.encode('utf-8').strip() + '\nmsgstr ""\n')


class Buffer(object):
    def __init__(self):
        self._stream = StringIO.StringIO()
        self._line_number = -1

    def get_value(self):
        return self._stream.getvalue()

    def get_line_number(self):
        return self._line_number

    def clear(self):
        self._stream.close()
        self._stream = StringIO.StringIO()
        self._line_number = -1

    def append(self, text, line_number):
        self._stream.write(text)
        if self._line_number < 0:
            self._line_number = line_number


def end_element_handler(input_file, name, messages, messages_map, text_buffer):
    if name == 'http://cubiware.com/i18n-v1.xsd:gettext':
        message_id = text_buffer.get_value()
        if message_id != '':
            if message_id not in messages_map:
                message = Message(message_id)
                messages.append(message)
                messages_map[message_id] = message
            messages_map[message_id].add_location(input_file, text_buffer.get_line_number())
    text_buffer.clear()


def parse_file(input_file, messages, messages_map):
    text_buffer = Buffer()
    parser = xml.parsers.expat.ParserCreate('UTF-8', ':')
    parser.StartElementHandler = lambda name, attrs: text_buffer.clear()
    parser.EndElementHandler = lambda name: end_element_handler(input_file, name, messages, messages_map, text_buffer)
    parser.CharacterDataHandler = lambda text: text_buffer.append(text, parser.CurrentLineNumber)

    try:
        with open(input_file, 'r') as f:
            data = f.read()
        parser.Parse(data, True)
    except IOError as ex:
        print("extract-xml-i18n-texts: error reading file '{0}'!".format(input_file), file = sys.stderr)
        traceback.print_exc()
        raise
    except Exception as ex:
        print("extract-xml-i18n-texts: error parsing XML file '{0}'!".format(input_file), file = sys.stderr)
        traceback.print_exc()
        raise


def main():
    parser = optparse.OptionParser(description = 'Extract strings in <i18n:gettext> tags from XML files.')
    parser.add_option('--no-location', dest = 'no_location', action = 'store_true',
                      default = False, help = "do not write '#: filename:line' lines")
    parser.add_option('-s', '--sort-output', dest = 'sort_output', action = 'store_true',
                      default = False, help = "generate sorted output")
    parser.add_option('--default-domain', '-d', dest = 'default_domain', metavar = 'NAME',
                      default = None, help = "use NAME.po for output (instead of messages.po)")
    parser.add_option('--output', '-o', dest = 'output', metavar = 'FILE',
                      default = 'messages.po', help = "write output to specified file")

    (options, args) = parser.parse_args()

    if len(args) == 0:
        print('extract-xml-i18n-texts: invalid usage, try --help', file = sys.stderr)
        return 1

    # parse input files
    messages = list()
    messages_map = dict()
    for input_file in args:
        try:
            parse_file(input_file, messages, messages_map)
        except Exception as ex:
            return 1

    if options.sort_output:
        messages.sort(key = lambda m: m.id)

    # generate output
    output_stream = None
    try:
        if options.output != '-':
            output_stream = open(options.output, 'w')
        else:
            output_stream = sys.stdout

        t = datetime.datetime.now(TimeZone())
        time_str = t.strftime('%Y-%m-%d %H:%M') + t.tzinfo.format()
        output_stream.write(header.format(time_str))
        for message in messages:
            output_stream.write('\n')
            message.dump(output_stream, options.no_location)
    except Exception as ex:
        print("extract-xml-i18n-texts: error writing output file '{0}'!".format(options.output), file = sys.stderr)
        traceback.print_exc()
        return 1
    finally:
        if output_stream and options.output != '-':
            output_stream.close()

    return 0


if __name__ == '__main__':
    sys.exit(main())
